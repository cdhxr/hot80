

## 1ï¸âƒ£ æ•°ç»„è½¬æ ‘

### ğŸ”— æ¨å¯¼é“¾
```
Q1: è¾“å…¥ä»€ä¹ˆï¼Ÿâ†’ æ‰å¹³æ•°ç»„ [{id, pid, name}, ...]
Q2: è¾“å‡ºä»€ä¹ˆï¼Ÿâ†’ æ ‘ç»“æ„ [{id, name, children: [...]}]
Q3: æ€ä¹ˆæ‰¾çˆ¶å­å…³ç³»ï¼Ÿâ†’ é€šè¿‡ pid æ‰¾ parent
Q4: é€’å½’ç‰ˆé—®é¢˜ï¼Ÿâ†’ æ¯ä¸ªèŠ‚ç‚¹éƒ½è¦éå†æ•´ä¸ªæ•°ç»„æ‰¾å­èŠ‚ç‚¹ï¼ŒO(nÂ²)
Q5: æ€ä¹ˆä¼˜åŒ–ï¼Ÿâ†’ Map å­˜æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¸€æ¬¡éå†å»ºç«‹å…³ç³»ï¼ŒO(n)
```

### ğŸ“Š å˜ä½“é€ŸæŸ¥

| å½¢æ€ | æ ¸å¿ƒ | å¤æ‚åº¦ |
|------|------|--------|
| é€’å½’ç‰ˆ | `filter` æ‰¾å­èŠ‚ç‚¹ï¼Œé€’å½’å¤„ç† | O(nÂ²) |
| Map ç‰ˆ | å…ˆå»º Mapï¼Œå†éå†è¿æ¥çˆ¶å­ | O(n) |

### ğŸ’» ä»£ç 
```javascript
// Map ä¼˜åŒ–ç‰ˆ - O(n)
function arrayToTree(arr, rootId = null) {
  const map = new Map();
  const result = [];
  
  // 1. æ‰€æœ‰èŠ‚ç‚¹å­˜å…¥ Map
  arr.forEach(item => {
    map.set(item.id, { ...item, children: [] });
  });
  
  // 2. å»ºç«‹çˆ¶å­å…³ç³»
  arr.forEach(item => {
    const node = map.get(item.id);
    if (item.pid === rootId) {
      result.push(node);
    } else {
      const parent = map.get(item.pid);
      if (parent) parent.children.push(node);
    }
  });
  
  return result;
}
```

---

## 2ï¸âƒ£ æ ‘è½¬æ•°ç»„

### ğŸ”— æ¨å¯¼é“¾
```
Q1: è¾“å…¥ä»€ä¹ˆï¼Ÿâ†’ æ ‘ç»“æ„
Q2: è¾“å‡ºä»€ä¹ˆï¼Ÿâ†’ æ‰å¹³æ•°ç»„ï¼Œå¸¦ pid
Q3: æ€ä¹ˆéå†ï¼Ÿâ†’ DFSï¼Œé€’å½’å¤„ç† children
Q4: pid æ€ä¹ˆæ¥ï¼Ÿâ†’ é€’å½’æ—¶ä¼ å…¥çˆ¶èŠ‚ç‚¹ id
```

### ğŸ’» ä»£ç 
```javascript
function treeToArray(tree, pid = null, result = []) {
  for (const node of tree) {
    const { id, name, children, ...rest } = node;
    result.push({ id, name, pid, ...rest });
    if (children?.length) {
      treeToArray(children, id, result);
    }
  }
  return result;
}
```

---

## 3ï¸âƒ£ è·¯å¾„å­—ç¬¦ä¸²è½¬æ ‘

### ğŸ”— æ¨å¯¼é“¾
```
Q1: è¾“å…¥ä»€ä¹ˆï¼Ÿâ†’ ['/a/b/c', '/a/b/d', '/a/e']
Q2: è¾“å‡ºä»€ä¹ˆï¼Ÿâ†’ æ ‘ç»“æ„ï¼Œç›¸åŒå‰ç¼€åˆå¹¶
Q3: æ€ä¹ˆå¤„ç†ï¼Ÿâ†’ æŒ‰ / åˆ†å‰²ï¼Œé€å±‚åˆ›å»ºèŠ‚ç‚¹
Q4: æ€ä¹ˆé¿å…é‡å¤åˆ›å»ºï¼Ÿâ†’ Map å­˜ path -> node æ˜ å°„
```

### ğŸ’» ä»£ç 
```javascript
function pathsToTree(paths) {
  const root = { name: 'root', children: [] };
  const map = new Map([['', root]]);  // path â†’ node
  
  for (let path of paths) {
    const parts = path.split('/').filter(p => p);
    let currPath = '';
    
    for (const part of parts) {
      currPath += '/' + part;
      if (!map.has(currPath)) {
        const node = { name: part, children: [] };
        const parent = map.get(currPath.substring(0, currPath.lastIndexOf('/')));
        parent.children.push(node);
        map.set(currPath, node);
      }
    }
  }
  return root.children;
}
```

---

## 4ï¸âƒ£ æŒ‰ç¼©è¿›æ„é€ æ ‘

### ğŸ”— æ¨å¯¼é“¾
```
Q1: è¾“å…¥ä»€ä¹ˆï¼Ÿâ†’ å¸¦ç¼©è¿›çš„æ–‡æœ¬
Q2: æ€ä¹ˆåˆ¤æ–­å±‚çº§ï¼Ÿâ†’ ç¼©è¿›ç©ºæ ¼æ•° / ç¼©è¿›å•ä½
Q3: æ€ä¹ˆæ‰¾çˆ¶èŠ‚ç‚¹ï¼Ÿâ†’ Map å­˜æ¯ä¸ª level çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
Q4: ç¼©è¿›å‡å°‘æ—¶ï¼Ÿâ†’ æ¸…ç†æ›´æ·±å±‚çº§çš„ Map è®°å½•
```

### ğŸ’» ä»£ç 
```javascript
function indentToTree(lines, indentSize = 2) {
  const root = { children: [] };
  const levelMap = new Map([[-1, root]]);  // level â†’ lastNode
  
  for (const line of lines) {
    const match = line.match(/^(\s*)(.*)/);
    const level = match[1].length / indentSize;
    const name = match[2].trim();
    
    const node = { name, children: [] };
    const parent = levelMap.get(level - 1);
    parent.children.push(node);
    
    // æ¸…ç†æ›´æ·±å±‚çº§ï¼Œæ›´æ–°å½“å‰å±‚çº§
    for (let l = level + 1; levelMap.has(l); l++) levelMap.delete(l);
    levelMap.set(level, node);
  }
  return root.children;
}
```

---

## 5ï¸âƒ£ äºŒå‰æ ‘éå†

### ğŸ”— æ¨å¯¼é“¾
```
Q1: ä¸‰ç§é¡ºåºï¼Ÿ
â†’ å‰åºï¼šæ ¹ â†’ å·¦ â†’ å³
â†’ ä¸­åºï¼šå·¦ â†’ æ ¹ â†’ å³  
â†’ ååºï¼šå·¦ â†’ å³ â†’ æ ¹

Q2: é€’å½’æ€ä¹ˆå†™ï¼Ÿâ†’ æ”¹å˜ push ä½ç½®
Q3: è¿­ä»£æ€ä¹ˆå†™ï¼Ÿâ†’ ç”¨æ ˆæ¨¡æ‹Ÿé€’å½’
Q4: ååºè¿­ä»£æŠ€å·§ï¼Ÿâ†’ æ ¹å³å·¦ ç„¶å reverse
```

### ğŸ“Š å˜ä½“é€ŸæŸ¥

| éå† | é€’å½’é¡ºåº | æ ˆè¿­ä»£æŠ€å·§ |
|------|----------|------------|
| å‰åº | æ ¹å·¦å³ | å…ˆ push å³å† push å·¦ |
| ä¸­åº | å·¦æ ¹å³ | ä¸€è·¯å‘å·¦å…¥æ ˆï¼Œå¼¹å‡ºå¤„ç†ï¼Œè½¬å³ |
| ååº | å·¦å³æ ¹ | æ ¹å³å·¦ + reverse |

### ğŸ’» ä»£ç 
```javascript
// å‰åºéå† - è¿­ä»£
function preorderIterative(root) {
  if (!root) return [];
  const result = [], stack = [root];
  while (stack.length) {
    const node = stack.pop();
    result.push(node.val);
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }
  return result;
}

// ä¸­åºéå† - è¿­ä»£
function inorderIterative(root) {
  const result = [], stack = [];
  let curr = root;
  while (curr || stack.length) {
    while (curr) {
      stack.push(curr);
      curr = curr.left;
    }
    curr = stack.pop();
    result.push(curr.val);
    curr = curr.right;
  }
  return result;
}

// ååºéå† - è¿­ä»£ï¼ˆæ ¹å³å·¦ + reverseï¼‰
function postorderIterative(root) {
  if (!root) return [];
  const result = [], stack = [root];
  while (stack.length) {
    const node = stack.pop();
    result.push(node.val);
    if (node.left) stack.push(node.left);
    if (node.right) stack.push(node.right);
  }
  return result.reverse();
}
```

---

## 6ï¸âƒ£ DOM æ ‘éå†

### ğŸ”— æ¨å¯¼é“¾
```
Q1: ä¸‰ç§æ–¹å¼ï¼Ÿ
â†’ DFS é€’å½’ï¼šæœ€ç›´è§‚
â†’ DFS æ ˆï¼šç”¨æ ˆæ¨¡æ‹Ÿé€’å½’
â†’ BFS é˜Ÿåˆ—ï¼šå±‚åºéå†

Q2: children é¡ºåºï¼Ÿ
â†’ DFS æ ˆè¦å€’åºå…¥æ ˆï¼ˆå…ˆå³åå·¦ï¼‰
â†’ BFS æ­£åºå…¥é˜Ÿ
```

### ğŸ’» ä»£ç 
```javascript
// DFS é€’å½’
function dfsRecursive(node, callback) {
  if (!node) return;
  callback(node);
  for (const child of node.children || []) {
    dfsRecursive(child, callback);
  }
}

// DFS æ ˆï¼ˆä¿æŒé¡ºåºéœ€å€’åºå…¥æ ˆï¼‰
function dfsStack(root, callback) {
  if (!root) return;
  const stack = [root];
  while (stack.length) {
    const node = stack.pop();
    callback(node);
    if (node.children) {
      for (let i = node.children.length - 1; i >= 0; i--) {
        stack.push(node.children[i]);
      }
    }
  }
}

// BFS é˜Ÿåˆ—ï¼ˆå±‚åºï¼‰
function bfs(root, callback) {
  if (!root) return;
  const queue = [root];
  while (queue.length) {
    const node = queue.shift();
    callback(node);
    if (node.children) {
      queue.push(...node.children);
    }
  }
}
```

---

## 7ï¸âƒ£ LRU ç¼“å­˜

### ğŸ”— æ¨å¯¼é“¾
```
Q1: LRU æ˜¯ä»€ä¹ˆï¼Ÿâ†’ æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼Œæ»¡äº†æ·˜æ±°æœ€ä¹…æ²¡ç”¨çš„
Q2: éœ€è¦ä»€ä¹ˆæ“ä½œï¼Ÿâ†’ get O(1)ã€put O(1)
Q3: æ€ä¹ˆå®ç° O(1)ï¼Ÿ
â†’ Map ç‰ˆï¼šåˆ©ç”¨ Map çš„æ’å…¥é¡ºåºï¼Œåˆ é™¤å†æ’å…¥å°±åˆ°æœ«å°¾
â†’ åŒå‘é“¾è¡¨ç‰ˆï¼šå¤´éƒ¨æœ€æ–°ï¼Œå°¾éƒ¨æœ€æ—§
```

### ğŸ“Š å˜ä½“é€ŸæŸ¥

| å½¢æ€ | æ ¸å¿ƒ | é€‚ç”¨ |
|------|------|------|
| Map ç‰ˆ | `delete + set` ç§»åˆ°æœ«å°¾ | é¢è¯•é¦–é€‰ï¼Œç®€å• |
| åŒå‘é“¾è¡¨ç‰ˆ | å¤´æ’ + å°¾åˆ  | è€ƒå¯Ÿæ•°æ®ç»“æ„ |

### ğŸ’» ä»£ç 
```javascript
// Map ç®€æ˜“ç‰ˆ
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.map = new Map();
  }
  
  get(key) {
    if (!this.map.has(key)) return -1;
    const val = this.map.get(key);
    this.map.delete(key);
    this.map.set(key, val);  // ç§»åˆ°æœ«å°¾ï¼ˆæœ€æ–°ï¼‰
    return val;
  }
  
  put(key, value) {
    if (this.map.has(key)) this.map.delete(key);
    else if (this.map.size >= this.capacity) {
      // åˆ é™¤ç¬¬ä¸€ä¸ªï¼ˆæœ€æ—§ï¼‰
      const firstKey = this.map.keys().next().value;
      this.map.delete(firstKey);
    }
    this.map.set(key, value);
  }
}
```

---

## 8ï¸âƒ£ å››å¤§æ’åº

### ğŸ”— æ¨å¯¼é“¾
```
Q1: å¿«æ’æ€è·¯ï¼Ÿâ†’ é€‰ pivotï¼Œå°çš„æ”¾å·¦è¾¹å¤§çš„æ”¾å³è¾¹ï¼Œé€’å½’
Q2: å½’å¹¶æ€è·¯ï¼Ÿâ†’ åˆ†ä¸¤åŠï¼Œé€’å½’æ’åºï¼Œåˆå¹¶æœ‰åºæ•°ç»„
Q3: å†’æ³¡æ€è·¯ï¼Ÿâ†’ ç›¸é‚»æ¯”è¾ƒï¼Œå¤§çš„å¾€åå†’
Q4: æ’å…¥æ€è·¯ï¼Ÿâ†’ åƒæ‰“ç‰Œï¼ŒæŠŠæ¯å¼ ç‰Œæ’å…¥å·²æ’åºéƒ¨åˆ†
```

### ğŸ“Š å˜ä½“é€ŸæŸ¥

| æ’åº | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´ | ç¨³å®š |
|------|-----------|------|------|
| å¿«æ’ | O(n log n) | O(log n) | âŒ |
| å½’å¹¶ | O(n log n) | O(n) | âœ… |
| å†’æ³¡ | O(nÂ²) | O(1) | âœ… |
| æ’å…¥ | O(nÂ²) | O(1) | âœ… |

### ğŸ’» ä»£ç 
```javascript
// å¿«é€Ÿæ’åº
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left >= right) return;
  const pivotIdx = partition(arr, left, right);
  quickSort(arr, left, pivotIdx - 1);
  quickSort(arr, pivotIdx + 1, right);
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left;
  for (let j = left; j < right; j++) {
    if (arr[j] < pivot) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      i++;
    }
  }
  [arr[i], arr[right]] = [arr[right], arr[i]];
  return i;
}

// å½’å¹¶æ’åº
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;
  while (i < left.length && j < right.length) {
    result.push(left[i] <= right[j] ? left[i++] : right[j++]);
  }
  return result.concat(left.slice(i), right.slice(j));
}
```

---

## 9ï¸âƒ£ è¯¾ç¨‹è¡¨ï¼ˆå›¾çš„ç¯æ£€æµ‹ï¼‰

### ğŸ”— æ¨å¯¼é“¾
```
Q1: é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿâ†’ åˆ¤æ–­è¯¾ç¨‹èƒ½å¦å…¨éƒ¨ä¿®å®Œï¼ˆæœ‰æ²¡æœ‰å¾ªç¯ä¾èµ–ï¼‰
Q2: æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿâ†’ æœ‰å‘å›¾æ£€æµ‹ç¯
Q3: æ€ä¹ˆå»ºå›¾ï¼Ÿâ†’ é‚»æ¥è¡¨ graph[a] = [b, c] è¡¨ç¤º a ä¾èµ– bã€c
Q4: æ€ä¹ˆæ£€æµ‹ç¯ï¼Ÿ
â†’ DFSï¼šä¸‰è‰²æ ‡è®°ï¼ˆç™½/ç°/é»‘ï¼‰ï¼Œé‡åˆ°ç°è‰²è¯´æ˜æœ‰ç¯
â†’ BFSï¼šæ‹“æ‰‘æ’åºï¼Œå…¥åº¦ä¸º 0 çš„å…ˆå¤„ç†ï¼Œæœ€åçœ‹æ˜¯å¦å…¨å¤„ç†å®Œ
```

### ğŸ“Š å˜ä½“é€ŸæŸ¥

| æ–¹æ³• | æ ¸å¿ƒ | åˆ¤æ–­æœ‰ç¯ |
|------|------|----------|
| DFS ä¸‰è‰² | ç™½â†’ç°â†’é»‘ï¼Œç°è‰²é‡ç°è‰² | è®¿é—®åˆ°ç°è‰²èŠ‚ç‚¹ |
| BFS æ‹“æ‰‘ | å…¥åº¦ä¸º 0 å…¥é˜Ÿï¼Œå¤„ç†åå‡å…¥åº¦ | å¤„ç†æ•° < æ€»æ•° |

### ğŸ’» ä»£ç 
```javascript
// BFS æ‹“æ‰‘æ’åº
function canFinish(numCourses, prerequisites) {
  const graph = Array.from({ length: numCourses }, () => []);
  const inDegree = Array(numCourses).fill(0);
  
  // å»ºå›¾ + è®¡ç®—å…¥åº¦
  for (const [to, from] of prerequisites) {
    graph[from].push(to);
    inDegree[to]++;
  }
  
  // å…¥åº¦ä¸º 0 çš„å…¥é˜Ÿ
  const queue = [];
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] === 0) queue.push(i);
  }
  
  let count = 0;
  while (queue.length) {
    const curr = queue.shift();
    count++;
    for (const next of graph[curr]) {
      if (--inDegree[next] === 0) queue.push(next);
    }
  }
  return count === numCourses;
}
```

---

## ğŸ”Ÿ è·¯å¾„æ€»å’Œ

### ğŸ”— æ¨å¯¼é“¾
```
Q1: è·¯å¾„æ€»å’Œ Iï¼Ÿâ†’ åˆ¤æ–­æ˜¯å¦å­˜åœ¨æ ¹åˆ°å¶è·¯å¾„å’Œç­‰äº target
Q2: è·¯å¾„æ€»å’Œ IIï¼Ÿâ†’ è¿”å›æ‰€æœ‰ç¬¦åˆçš„è·¯å¾„
Q3: è·¯å¾„æ€»å’Œ IIIï¼Ÿâ†’ è·¯å¾„ä¸ä¸€å®šä»æ ¹å¼€å§‹ï¼Œä¸ä¸€å®šåˆ°å¶ç»“æŸ
Q4: æ ¸å¿ƒæŠ€å·§ï¼Ÿâ†’ DFS + å›æº¯ï¼Œä¼ é€’å‰©ä½™ç›®æ ‡å€¼
```

### ğŸ’» ä»£ç 
```javascript
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

// è·¯å¾„æ€»å’Œ Iï¼šæ˜¯å¦å­˜åœ¨
function hasPathSum(root, target) {
  if (!root) return false;
  // å¶å­èŠ‚ç‚¹ï¼šåˆ¤æ–­å‰©ä½™å€¼æ˜¯å¦ç­‰äºå½“å‰èŠ‚ç‚¹å€¼
  if (!root.left && !root.right) return root.val === target;
  const remain = target - root.val;
  return hasPathSum(root.left, remain) || hasPathSum(root.right, remain);
}

// è·¯å¾„æ€»å’Œ IIï¼šè¿”å›æ‰€æœ‰è·¯å¾„
function pathSum(root, target) {
  const result = [];
  
  function dfs(node, remain, path) {
    if (!node) return;
    path.push(node.val);
    
    // å¶å­èŠ‚ç‚¹ä¸”è·¯å¾„å’Œç­‰äºç›®æ ‡
    if (!node.left && !node.right && remain === node.val) {
      result.push([...path]);
    }
    
    dfs(node.left, remain - node.val, path);
    dfs(node.right, remain - node.val, path);
    path.pop();  // å›æº¯
  }
  
  dfs(root, target, []);
  return result;
}

// è·¯å¾„æ€»å’Œ IIIï¼šä»»æ„èµ·ç‚¹ç»ˆç‚¹
function pathSumIII(root, target) {
  if (!root) return 0;
  
  // ä»å½“å‰èŠ‚ç‚¹å¼€å§‹çš„è·¯å¾„æ•°
  function countFromNode(node, remain) {
    if (!node) return 0;
    let count = node.val === remain ? 1 : 0;
    count += countFromNode(node.left, remain - node.val);
    count += countFromNode(node.right, remain - node.val);
    return count;
  }
  
  // æ€»æ•° = ä»æ ¹å¼€å§‹ + å·¦å­æ ‘çš„ + å³å­æ ‘çš„
  return countFromNode(root, target) + 
         pathSumIII(root.left, target) + 
         pathSumIII(root.right, target);
}

// æ„å»ºæµ‹è¯•æ ‘:      
//           5
//         /   \
//        4     8
//       /     / \
//      11    13  4
//     / \        / \
//    7   2      5   1
const root = new TreeNode(5,
  new TreeNode(4, new TreeNode(11, new TreeNode(7), new TreeNode(2))),
  new TreeNode(8, new TreeNode(13), new TreeNode(4, new TreeNode(5), new TreeNode(1)))
);

console.log(hasPathSum(root, 22));  // true (5â†’4â†’11â†’2)
console.log(pathSum(root, 22));     // [[5,4,11,2]]
console.log(pathSumIII(root, 8));   // 3 (5â†’3, 11â†’-3, 4â†’4)
```

---

> ğŸ“Œ **ä½¿ç”¨å»ºè®®**
> 1. å…ˆç†è§£æ¨å¯¼é“¾çš„ Q&A é€»è¾‘ï¼Œå†èƒŒä»£ç 
> 2. å˜ä½“é€ŸæŸ¥è¡¨ç”¨äºé¢è¯•å¿«é€Ÿå›å¿†æ ¸å¿ƒç‚¹
> 3. ä»£ç å»ºè®®æ‰‹æ•² 3 éï¼šçœ‹â†’é»˜å†™â†’ä¼˜åŒ–

> âœ¨ **è¿›é˜¶æ€è€ƒ**
> - æ•°ç»„è½¬æ ‘ï¼šå¦‚æœæ•°æ®é‡ 10w+ï¼Œå¦‚ä½•æµå¼å¤„ç†ï¼Ÿ
> - LRUï¼šå¦‚æœè¦æ±‚çº¿ç¨‹å®‰å…¨ï¼Œæ€ä¹ˆæ”¹é€ ï¼Ÿ
> - æ‹“æ‰‘æ’åºï¼šå¦‚ä½•è¾“å‡ºä¸€ä¸ªåˆæ³•çš„ä¿®è¯¾é¡ºåºï¼Ÿ