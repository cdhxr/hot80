
## 1ï¸âƒ£ æ·±æ‹·è´ Deep Clone

### ğŸ”— æ¨å¯¼é“¾
```
Q1: ä¸ºä»€ä¹ˆéœ€è¦æ·±æ‹·è´ï¼Ÿ
â†’ æµ…æ‹·è´åªå¤åˆ¶ç¬¬ä¸€å±‚ï¼ŒåµŒå¥—å¯¹è±¡è¿˜æ˜¯å…±äº«å¼•ç”¨
â†’ ä¿®æ”¹æ‹·è´ä¼šå½±å“åŸå¯¹è±¡

Q2: æœ€ç®€å•æ–¹æ¡ˆï¼Ÿ
â†’ JSON.parse(JSON.stringify(obj))
â†’ ç¼ºç‚¹ï¼šä¸¢å¤± functionã€undefinedã€Symbolã€å¾ªç¯å¼•ç”¨æŠ¥é”™

Q3: æ€ä¹ˆå¤„ç†å¾ªç¯å¼•ç”¨ï¼Ÿ
â†’ WeakMap è®°å½•å·²æ‹·è´çš„å¯¹è±¡
â†’ é‡åˆ°å·²æ‹·è´çš„ç›´æ¥è¿”å›ç¼“å­˜

Q4: ç‰¹æ®Šç±»å‹æ€ä¹ˆå¤„ç†ï¼Ÿ
â†’ Date: new Date(obj.getTime())
â†’ RegExp: new RegExp(obj.source, obj.flags)
â†’ Function: ç›´æ¥è¿”å›ï¼ˆå‡½æ•°ä¸€èˆ¬ä¸éœ€è¦æ‹·è´ï¼‰
â†’ Map/Set: éå†é€’å½’æ‹·è´
```

### ğŸ“Š å˜ä½“é€ŸæŸ¥

| å½¢æ€ | é€‚ç”¨åœºæ™¯ |
|------|----------|
| JSON ç‰ˆ | ç®€å•å¯¹è±¡ï¼Œæ— å‡½æ•°/å¾ªç¯å¼•ç”¨ |
| åŸºç¡€é€’å½’ç‰ˆ | æ™®é€šåµŒå¥—å¯¹è±¡ |
| å¾ªç¯å¼•ç”¨ç‰ˆ | æœ‰å¾ªç¯å¼•ç”¨çš„å¯¹è±¡ |
| å®Œæ•´ç‰ˆ | åŒ…å« Date/RegExp/Map/Set/Function |

### ğŸ’» ä»£ç 
```javascript
function deepClone(obj, hash = new WeakMap()) {
  // åŸºæœ¬ç±»å‹ + null
  if (obj === null || typeof obj !== 'object') return obj;
  
  // å¾ªç¯å¼•ç”¨æ£€æµ‹
  if (hash.has(obj)) return hash.get(obj);
  
  // Date
  if (obj instanceof Date) return new Date(obj.getTime());
  
  // RegExp
  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);
  
  // Map
  if (obj instanceof Map) {
    const result = new Map();
    hash.set(obj, result);
    obj.forEach((v, k) => result.set(k, deepClone(v, hash)));
    return result;
  }
  
  // Set
  if (obj instanceof Set) {
    const result = new Set();
    hash.set(obj, result);
    obj.forEach(v => result.add(deepClone(v, hash)));
    return result;
  }
  
  // Array / Object
  const result = Array.isArray(obj) ? [] : {};
  hash.set(obj, result);
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key], hash);
    }
  }
  return result;
}
```

---

## 2ï¸âƒ£ æ·±åº¦æ¯”è¾ƒ deepEqual

### ğŸ”— æ¨å¯¼é“¾
```
Q1: ä»€ä¹ˆæ—¶å€™è¿”å› trueï¼Ÿ
â†’ åŸºæœ¬ç±»å‹ï¼šå€¼ç›¸ç­‰
â†’ å¼•ç”¨ç±»å‹ï¼šç»“æ„å’Œå€¼éƒ½ç›¸ç­‰

Q2: æ€ä¹ˆåˆ¤æ–­ç±»å‹ï¼Ÿ
â†’ Object.prototype.toString.call() ç²¾ç¡®åˆ¤æ–­

Q3: é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼Ÿ
â†’ === ç›¸ç­‰ï¼ˆåŒ…æ‹¬åŒä¸€å¼•ç”¨ï¼‰
â†’ null/undefined
â†’ ç±»å‹ä¸åŒ

Q4: ç‰¹æ®Šç±»å‹æ€ä¹ˆæ¯”ï¼Ÿ
â†’ Date: æ¯”è¾ƒ getTime()
â†’ RegExp: æ¯”è¾ƒ toString()
â†’ æ•°ç»„: é•¿åº¦ + é€ä¸ªé€’å½’
â†’ å¯¹è±¡: é”®æ•°é‡ + é€ä¸ªé€’å½’
```

### ğŸ’» ä»£ç 
```javascript
function deepEqual(a, b) {
  // åŒä¸€å¼•ç”¨æˆ–åŸºæœ¬ç±»å‹ç›¸ç­‰
  if (a === b) return true;
  
  // null/undefined æˆ–ç±»å‹ä¸åŒ
  if (a == null || b == null) return false;
  if (typeof a !== typeof b) return false;
  
  // å¯¹è±¡ç±»å‹ç²¾ç¡®åˆ¤æ–­
  const typeA = Object.prototype.toString.call(a);
  const typeB = Object.prototype.toString.call(b);
  if (typeA !== typeB) return false;
  
  // Date
  if (a instanceof Date) return a.getTime() === b.getTime();
  
  // RegExp
  if (a instanceof RegExp) return a.toString() === b.toString();
  
  // Array
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) return false;
    }
    return true;
  }
  
  // Object
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  
  for (const key of keysA) {
    if (!keysB.includes(key) || !deepEqual(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
```

---

## 3ï¸âƒ£ lodash getï¼ˆå®‰å…¨å–å€¼ï¼‰

### ğŸ”— æ¨å¯¼é“¾
```
Q1: å¹²å˜›ç”¨ï¼Ÿ
â†’ å®‰å…¨å–å€¼ï¼Œé¿å… Cannot read property of undefined
â†’ get(obj, 'a.b.c') ä»£æ›¿ obj?.a?.b?.c

Q2: è·¯å¾„æ€ä¹ˆè§£æï¼Ÿ
â†’ 'a.b[0].c' â†’ ['a', 'b', '0', 'c']
â†’ éå†å­—ç¬¦ï¼Œé‡åˆ° [ ] . åˆ†å‰²

Q3: å–å€¼é€»è¾‘ï¼Ÿ
â†’ éå†è·¯å¾„æ•°ç»„ï¼Œé€å±‚å–å€¼
â†’ ä¸­é€”é‡åˆ° null/undefined è¿”å›é»˜è®¤å€¼
```

### ğŸ’» ä»£ç 
```javascript
function get(obj, path, defaultValue) {
  // è§£æè·¯å¾„: 'a.b[0].c' â†’ ['a', 'b', '0', 'c']
  const keys = path
    .replace(/\[(\w+)\]/g, '.$1')  // a[0] â†’ a.0
    .replace(/^\./, '')            // å»æ‰å¼€å¤´ .
    .split('.')
    .filter(k => k !== '');
  
  let result = obj;
  for (const key of keys) {
    if (result == null) return defaultValue;
    result = result[key];
  }
  return result === undefined ? defaultValue : result;
}

// æµ‹è¯•
const obj = { a: { b: { c: [1, 2, 3] } } };
console.log(get(obj, 'a.b.c[1]'));        // 2
console.log(get(obj, 'a.x.y', 'default')); // 'default'
```

---

## 4ï¸âƒ£ lodash setï¼ˆå®‰å…¨èµ‹å€¼ï¼‰

### ğŸ”— æ¨å¯¼é“¾
```
Q1: å’Œ get åŒºåˆ«ï¼Ÿ
â†’ get æ˜¯å–å€¼ï¼Œset æ˜¯èµ‹å€¼
â†’ è·¯å¾„ä¸å­˜åœ¨è¦è‡ªåŠ¨åˆ›å»º

Q2: æ€ä¹ˆåˆ¤æ–­åˆ›å»ºå¯¹è±¡è¿˜æ˜¯æ•°ç»„ï¼Ÿ
â†’ çœ‹ä¸‹ä¸€ä¸ª key æ˜¯ä¸æ˜¯æ•°å­—
â†’ æ˜¯æ•°å­—åˆ›å»º []ï¼Œå¦åˆ™åˆ›å»º {}

Q3: éå†åˆ°å“ªï¼Ÿ
â†’ éå†åˆ°å€’æ•°ç¬¬äºŒå±‚ï¼Œæœ€åä¸€å±‚ç›´æ¥èµ‹å€¼
```

### ğŸ’» ä»£ç 
```javascript
function set(obj, path, value) {
  const keys = path
    .replace(/\[(\w+)\]/g, '.$1')
    .replace(/^\./, '')
    .split('.')
    .filter(k => k !== '');
  
  let current = obj;
  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    const nextKey = keys[i + 1];
    
    // åˆ¤æ–­åˆ›å»ºæ•°ç»„è¿˜æ˜¯å¯¹è±¡
    if (current[key] === undefined) {
      current[key] = /^\d+$/.test(nextKey) ? [] : {};
    }
    current = current[key];
  }
  current[keys[keys.length - 1]] = value;
  return obj;
}

// æµ‹è¯•
const obj = {};
set(obj, 'a.b[0].c', 123);
console.log(obj);  // { a: { b: [ { c: 123 } ] } }
```

---

## 5ï¸âƒ£ getType ç²¾ç¡®ç±»å‹åˆ¤æ–­

### ğŸ”— æ¨å¯¼é“¾
```
Q1: typeof æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
â†’ typeof null === 'object'
â†’ æ•°ç»„ã€Dateã€RegExp éƒ½æ˜¯ 'object'

Q2: æ€ä¹ˆç²¾ç¡®åˆ¤æ–­ï¼Ÿ
â†’ Object.prototype.toString.call()
â†’ è¿”å› '[object Type]'

Q3: ä¸ºä»€ä¹ˆç”¨ callï¼Ÿ
â†’ ç›´æ¥è°ƒç”¨ä¼šè¢«è¦†ç›–
â†’ call å¼ºåˆ¶ä½¿ç”¨åŸå§‹æ–¹æ³•
```

### ğŸ’» ä»£ç 
```javascript
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}

// æµ‹è¯•
console.log(getType(null));           // 'null'
console.log(getType([]));             // 'array'
console.log(getType(new Date()));     // 'date'
console.log(getType(/regex/));        // 'regexp'
console.log(getType(Map));            // 'function'
console.log(getType(Symbol()));       // 'symbol'
```

---

## 6ï¸âƒ£ æ•°ç»„æ‰å¹³åŒ– flat

### ğŸ”— æ¨å¯¼é“¾
```
Q1: flat å¹²å˜›ï¼Ÿ
â†’ [[1, [2]], 3] â†’ [1, 2, 3]
â†’ å¤šç»´æ•°ç»„æ‹å¹³æˆä¸€ç»´

Q2: æ€ä¹ˆæ§åˆ¶æ·±åº¦ï¼Ÿ
â†’ depth å‚æ•°ï¼Œæ¯é€’å½’ä¸€å±‚å‡ä¸€
â†’ depth <= 0 ä¸å†å±•å¼€

Q3: ä¸¤ç§å†™æ³•ï¼Ÿ
â†’ for å¾ªç¯ + push
â†’ reduce + concat
```

### ğŸ’» ä»£ç 
```javascript
// é€’å½’ç‰ˆ
function flat(arr, depth = 1) {
  if (depth <= 0) return arr.slice();
  
  const result = [];
  for (const item of arr) {
    if (Array.isArray(item)) {
      result.push(...flat(item, depth - 1));
    } else {
      result.push(item);
    }
  }
  return result;
}

// reduce ç‰ˆ
function flatReduce(arr, depth = 1) {
  if (depth <= 0) return arr.slice();
  
  return arr.reduce((acc, item) => {
    return acc.concat(
      Array.isArray(item) ? flatReduce(item, depth - 1) : item
    );
  }, []);
}

// æ— é™æ·±åº¦ç‰ˆ
function flatInfinite(arr) {
  const result = [];
  const stack = [...arr];
  
  while (stack.length) {
    const item = stack.pop();
    if (Array.isArray(item)) {
      stack.push(...item);
    } else {
      result.unshift(item);
    }
  }
  return result;
}

// æµ‹è¯•
console.log(flat([1, [2, [3, [4]]]], 2));  // [1, 2, 3, [4]]
console.log(flatInfinite([1, [2, [3, [4]]]]));  // [1, 2, 3, 4]
```

---

## 7ï¸âƒ£ å¯¹è±¡æ‰å¹³åŒ– flattenObj

### ğŸ”— æ¨å¯¼é“¾
```
Q1: å¹²å˜›ç”¨ï¼Ÿ
â†’ { a: { b: 1 } } â†’ { 'a.b': 1 }
â†’ åµŒå¥—å¯¹è±¡è½¬æˆæ‰å¹³é”®å€¼å¯¹

Q2: æ€ä¹ˆæ‹¼æ¥ keyï¼Ÿ
â†’ é€’å½’æ—¶ä¼ é€’ prevKey
â†’ æ–° key = `${prevKey}.${currentKey}`

Q3: é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼Ÿ
â†’ ä¸æ˜¯å¯¹è±¡æˆ–åˆ°è¾¾æŒ‡å®šæ·±åº¦
â†’ ç›´æ¥å­˜å…¥ç»“æœ
```

### ğŸ’» ä»£ç 
```javascript
function flattenObj(obj, prefix = '', depth = Infinity, currentDepth = 0) {
  if (currentDepth >= depth || typeof obj !== 'object' || obj === null) {
    return { [prefix]: obj };
  }
  
  if (Array.isArray(obj)) {
    return obj.reduce((acc, item, index) => {
      return { ...acc, ...flattenObj(item, `${prefix}[${index}]`, depth, currentDepth + 1) };
    }, {});
  }
  
  return Object.keys(obj).reduce((acc, key) => {
    const newKey = prefix ? `${prefix}.${key}` : key;
    return { ...acc, ...flattenObj(obj[key], newKey, depth, currentDepth + 1) };
  }, {});
}

// æµ‹è¯•
const obj = { a: { b: { c: 1 } }, d: [2, 3] };
console.log(flattenObj(obj));
// { 'a.b.c': 1, 'd[0]': 2, 'd[1]': 3 }
```

---

## 8ï¸âƒ£ æ•°ç»„å»é‡

### ğŸ”— æ¨å¯¼é“¾
```
Q1: æœ€ç®€å•æ–¹æ¡ˆï¼Ÿ
â†’ [...new Set(arr)]
â†’ åªèƒ½å»é‡åŸºæœ¬ç±»å‹

Q2: å¯¹è±¡æ•°ç»„æ€ä¹ˆå»é‡ï¼Ÿ
â†’ æŒ‡å®š keyï¼Œç”¨ Map è®°å½•
â†’ æˆ–è€…ç”¨ JSON.stringify ä½œä¸º key

Q3: å¤šç§å†™æ³•ï¼Ÿ
â†’ Setã€filter + indexOfã€reduce + includes
```

### ğŸ’» ä»£ç 
```javascript
// åŸºæœ¬ç±»å‹å»é‡
function uniqueBasic(arr) {
  return [...new Set(arr)];
}

// å¯¹è±¡æ•°ç»„å»é‡ï¼ˆæŒ‡å®š keyï¼‰
function uniqueBy(arr, key) {
  const map = new Map();
  return arr.filter(item => {
    const k = typeof key === 'function' ? key(item) : item[key];
    if (map.has(k)) return false;
    map.set(k, true);
    return true;
  });
}

// å¯¹è±¡æ•°ç»„å»é‡ï¼ˆJSON åºåˆ—åŒ–ï¼‰
function uniqueByJSON(arr) {
  const seen = new Set();
  return arr.filter(item => {
    const str = JSON.stringify(item);
    if (seen.has(str)) return false;
    seen.add(str);
    return true;
  });
}

// æµ‹è¯•
const nums = [1, 2, 2, 3, 1];
console.log(uniqueBasic(nums));  // [1, 2, 3]

const users = [
  { id: 1, name: 'a' },
  { id: 2, name: 'b' },
  { id: 1, name: 'a' }
];
console.log(uniqueBy(users, 'id'));  // [{id:1}, {id:2}]
```

---

## 9ï¸âƒ£ æ•°ç»„æ–¹æ³•å®ç°ï¼ˆmap/filter/reduceï¼‰

### ğŸ”— æ¨å¯¼é“¾
```
Q1: map å¹²å˜›ï¼Ÿ
â†’ éå†æ•°ç»„ï¼Œå¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œå›è°ƒï¼Œè¿”å›æ–°æ•°ç»„
â†’ å›è°ƒå‚æ•°ï¼š(item, index, array)

Q2: filter å¹²å˜›ï¼Ÿ
â†’ éå†æ•°ç»„ï¼Œä¿ç•™å›è°ƒè¿”å› true çš„å…ƒç´ 

Q3: reduce å¹²å˜›ï¼Ÿ
â†’ ç´¯åŠ å™¨ï¼ŒæŠŠæ•°ç»„å½’çº¦æˆå•ä¸ªå€¼
â†’ å›è°ƒå‚æ•°ï¼š(acc, item, index, array)
```

### ğŸ’» ä»£ç 
```javascript
// Array.prototype.map å®ç°
function myMap(arr, callback, thisArg) {
  if (arr == null) throw new TypeError('Cannot read property of null');
  if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');
  
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (i in arr) {  // å¤„ç†ç¨€ç–æ•°ç»„
      result[i] = callback.call(thisArg, arr[i], i, arr);
    }
  }
  return result;
}

// Array.prototype.filter å®ç°
function myFilter(arr, callback, thisArg) {
  if (arr == null) throw new TypeError('Cannot read property of null');
  if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');
  
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (i in arr && callback.call(thisArg, arr[i], i, arr)) {
      result.push(arr[i]);
    }
  }
  return result;
}

// Array.prototype.reduce å®ç°
function myReduce(arr, callback, initialValue) {
  if (arr == null) throw new TypeError('Cannot read property of null');
  if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');
  
  let acc = initialValue;
  let startIdx = 0;
  
  // æœªä¼ åˆå§‹å€¼ï¼Œç”¨ç¬¬ä¸€ä¸ªå…ƒç´ 
  if (initialValue === undefined) {
    if (arr.length === 0) throw new TypeError('Reduce of empty array with no initial value');
    acc = arr[0];
    startIdx = 1;
  }
  
  for (let i = startIdx; i < arr.length; i++) {
    if (i in arr) {
      acc = callback(acc, arr[i], i, arr);
    }
  }
  return acc;
}

// æµ‹è¯•
console.log(myMap([1, 2, 3], x => x * 2));        // [2, 4, 6]
console.log(myFilter([1, 2, 3], x => x > 1));     // [2, 3]
console.log(myReduce([1, 2, 3], (a, b) => a + b, 0));  // 6
```

---

## ğŸ”Ÿ Omit / Pickï¼ˆJS + TS ç±»å‹ï¼‰

### ğŸ”— æ¨å¯¼é“¾
```
Q1: Pick å¹²å˜›ï¼Ÿ
â†’ ä»å¯¹è±¡ä¸­é€‰å–æŒ‡å®šå±æ€§
â†’ pick(obj, ['a', 'b']) â†’ { a, b }

Q2: Omit å¹²å˜›ï¼Ÿ
â†’ ä»å¯¹è±¡ä¸­æ’é™¤æŒ‡å®šå±æ€§
â†’ omit(obj, ['a']) â†’ é™¤äº† a çš„å…¶ä»–å±æ€§

Q3: TS ç±»å‹æ€ä¹ˆå®ç°ï¼Ÿ
â†’ Pick: [P in K]: T[P]
â†’ Omit: [P in Exclude<keyof T, K>]: T[P]
```

### ğŸ’» ä»£ç ï¼ˆJS å®ç°ï¼‰
```javascript
function pick(obj, keys) {
  const keySet = new Set(Array.isArray(keys) ? keys : [keys]);
  return Object.keys(obj).reduce((result, key) => {
    if (keySet.has(key)) result[key] = obj[key];
    return result;
  }, {});
}

function omit(obj, keys) {
  const keySet = new Set(Array.isArray(keys) ? keys : [keys]);
  return Object.keys(obj).reduce((result, key) => {
    if (!keySet.has(key)) result[key] = obj[key];
    return result;
  }, {});
}

// æµ‹è¯•
const user = { id: 1, name: 'å¼ ä¸‰', email: 'test@test.com', password: '123' };
console.log(pick(user, ['id', 'name']));     // { id: 1, name: 'å¼ ä¸‰' }
console.log(omit(user, ['password']));       // { id: 1, name: 'å¼ ä¸‰', email: 'test@test.com' }
```

### ğŸ’» ä»£ç ï¼ˆTS ç±»å‹å®ç°ï¼‰
```typescript
// Pick: ä» T ä¸­é€‰å– K æŒ‡å®šçš„å±æ€§
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P]
}

// Omit: ä» T ä¸­æ’é™¤ K æŒ‡å®šçš„å±æ€§
type MyOmit<T, K extends keyof T> = {
  [P in Exclude<keyof T, K>]: T[P]
}

// Exclude: ä» T ä¸­æ’é™¤å¯ä»¥èµ‹å€¼ç»™ U çš„ç±»å‹
type MyExclude<T, U> = T extends U ? never : T

// ä½¿ç”¨ç¤ºä¾‹
interface User {
  id: number
  name: string
  email: string
  password: string
}

type UserBasic = MyPick<User, 'id' | 'name'>  // { id: number, name: string }
type UserPublic = MyOmit<User, 'password'>    // { id: number, name: string, email: string }
```

---

## 1ï¸âƒ£1ï¸âƒ£ ä»£ç†æ•°ç»„ï¼ˆå“åº”å¼ç›‘å¬ï¼‰

### ğŸ”— æ¨å¯¼é“¾
```
Q1: Proxy èƒ½å¹²å˜›ï¼Ÿ
â†’ æ‹¦æˆªæ•°ç»„çš„ get/set æ“ä½œ
â†’ ç›‘å¬æ•°ç»„å˜æ›´ï¼Œè§¦å‘å›è°ƒ

Q2: éœ€è¦æ‹¦æˆªå“ªäº›æ–¹æ³•ï¼Ÿ
â†’ å˜æ›´æ–¹æ³•: push/pop/shift/unshift/splice/sort/reverse
â†’ ç´¢å¼•èµ‹å€¼: arr[0] = x

Q3: æ€ä¹ˆé€šçŸ¥å˜æ›´ï¼Ÿ
â†’ onChange å›è°ƒè¿”å›å˜æ›´è¯¦æƒ…
â†’ { method, args } æˆ– { type, key, oldValue, newValue }
```

### ğŸ’» ä»£ç 
```javascript
function reactiveArray(arr, onChange) {
  const methods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

  return new Proxy(arr, {
    get(target, key, receiver) {
      // æ‹¦æˆªå˜æ›´æ–¹æ³•
      if (methods.includes(key)) {
        return function(...args) {
          const result = Reflect.apply(target[key], target, args);
          onChange({ method: key, args, result });
          return result;
        };
      }
      return Reflect.get(target, key, receiver);
    },
    
    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);
      
      // é€šçŸ¥å˜æ›´ï¼ˆæ’é™¤ length å±æ€§ï¼‰
      if (key !== 'length' && result) {
        onChange({ type: 'set', key, oldValue, newValue: value });
      }
      return result;
    },
    
    deleteProperty(target, key) {
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result) {
        onChange({ type: 'delete', key, oldValue });
      }
      return result;
    }
  });
}

// ä½¿ç”¨ç¤ºä¾‹
const arr = reactiveArray([1, 2, 3], (info) => {
  console.log('ğŸ”„ å˜æ›´:', info);
});

arr.push(4);           // ğŸ”„ å˜æ›´: { method: 'push', args: [4], result: 4 }
arr[0] = 10;           // ğŸ”„ å˜æ›´: { type: 'set', key: '0', oldValue: 1, newValue: 10 }
arr.splice(1, 1);      // ğŸ”„ å˜æ›´: { method: 'splice', args: [1, 1], result: [2] }
delete arr[2];         // ğŸ”„ å˜æ›´: { type: 'delete', key: '2', oldValue: 3 }
```

---

> ğŸ“Œ **ä½¿ç”¨å»ºè®®**
> 1. **æ·±æ‹·è´**ï¼šç”Ÿäº§ç¯å¢ƒæ¨èä½¿ç”¨ structuredCloneï¼ˆç°ä»£æµè§ˆå™¨ï¼‰æˆ– immerï¼ˆä¸å¯å˜æ›´æ–°ï¼‰
> 2. **get/set**ï¼šè·¯å¾„è§£æè¦è€ƒè™‘è¾¹ç•Œæƒ…å†µï¼Œå»ºè®®åŠ å•å…ƒæµ‹è¯•
> 3. **æ•°ç»„å»é‡**ï¼šå¯¹è±¡æ•°ç»„å»é‡æ³¨æ„å¼•ç”¨ç›¸ç­‰ vs å€¼ç›¸ç­‰
> 4. **Proxy**ï¼šæ³¨æ„æ€§èƒ½å¼€é”€ï¼Œé¿å…è¿‡åº¦ä½¿ç”¨

> âœ¨ **è¿›é˜¶æ€è€ƒ**
> - æ·±æ‹·è´ï¼šå¦‚ä½•æ”¯æŒ BigIntã€Errorã€Promise ç­‰ç‰¹æ®Šç±»å‹ï¼Ÿ
> - flatï¼šå¦‚ä½•ç”¨ç”Ÿæˆå™¨å®ç°æƒ°æ€§æ‰å¹³åŒ–ï¼Ÿ
> - å“åº”å¼æ•°ç»„ï¼šå¦‚ä½•æ”¯æŒåµŒå¥—å¯¹è±¡çš„æ·±åº¦ç›‘å¬ï¼Ÿ